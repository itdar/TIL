# 토비의 스프링 3.1 Vol.1

1. [오브젝트와 의존관계](#1장.-오브젝트와-의존관계)


## 1장. 오브젝트와 의존관계

### 생각 해볼 내용
- 객체지향 원칙 SOLID
  - SRP, OCP, LSP, ISP, DIP
- 전략 패턴
- 템플릿메서드 패턴
- 싱글톤 패턴
- 팩토리 패턴
- 템플릿콜백 패턴
- 낮은 결합도
- 높은 응집도
- 제어의 역전 (IoC)
- 라이브러리와 프레임워크의 차이
- 싱글톤 레지스트리
- 싱글톤과 멀티쓰레딩 환경
- 오브젝트 스코프
- 의존관계 주입 (DI)
  - 런타임 의존관계 주입
- Annotation, XML 을 통한 Configuration

> 스프링은 오브젝트가 어떻게 설계되고, 만들어지고, 관계를 맺고, 사용되는지에 관심을 둔 프레임워크.
>
> 오브젝트 + 관계

<br> 

### 내용
- User, UserDao 난감 클래스 예시
- UserDao 에서 메서드마다 중복되는 DB Connection 코드를 분리한다.
  - 중복코드 메서드 분리 (관심사 분리)
- UserDao 에서 확장을 해본다. (D사, N사)
  - 상속을 통해서 확장 (XUserDao...)
  - 템플릿메소드 패턴 사용
    - 팩토리메소드 패턴 으로 볼 수도 있음
- UserDao 에서 인터페이스를 통한 확장을 해본다.
  - User 에서 인터페이스를 의존하여 불필요한 의존 제거 
    - 높은 응집도, 낮은 결합도
    - 전략패턴 사용
    - OCP (개방 폐쇄 원칙) 지킴
    - 런타임 오브젝트 관계를 갖는 구조
- 오브젝트 팩토리를 통한 제어의 역전
  - 애플리케이션 컴포넌트 역할의 오브젝트와 애플리케이션 구조 결정 오브젝트를 분리
  - 오브젝트 팩토리: 프레임워크 또는 컨테이너 처럼 애플리케이션 컴포넌트의 생성, 관계설정, 사용, 생명주기 관리 등을 관장하는 존재
  - 설계도(Blueprint) 역할
- 스프링을 이용한 IoC, 애플리케이션 컨텍스트
  - 구체적인 팩토리 클래스 알 필요 없음, 더 다양한 기능 제공 (오브젝트 팩토리와의 비교 장점)
- 자바 싱글톤 패턴의 문제를 해결하는 스프링의 싱글톤 레지스트리
  - 서버의 서비스 오브젝트로서의 장점을 살리는 싱글톤을 사용하면서, 패턴의 단점 극복하게 설계됨
  - public 생성자 소유 가능
  - 테스트를 위한 목 오브젝트 사용 가능
  - 다른 객체지향 설계 방식원칙 등을 따르는 데에 문제가 없음
- 스프링의 빈 스코프
  - singleton, prototype, request, session...
- 의존관계 주입을 통한 런타임 의존관계 설정
  - 클래스 모델이나 코드에는 런타임 시점의 의존관계 드러나지 않음. 그렇기위해 인터페이스에만 의존한다.
  - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 3자가 결정
  - 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공하여 만들어짐
  - DI, DL(lookup, 검색)
- Annotation 외에 XML 을 이용한 Configuration
  - DTD, Schema

---
## 2장. 테스트

### 생각 해볼 내용
- 관심사의 분리
- 단위테스트 (Unit test)
  - 단위란?
- TDD(Test Driven Development), TFD(Test First Development)
- 테스트픽스처 (Fixture)
- @DirtiesContext
- 침투적/비침투적 기술 (invasive/noninvalsive)
- 동등분할(equivalence partitioning), 경계값 분석(boundary value analysis)

> 스프링이 개발자에게 제공하는 가장 중요한 가치는   
> -> 객체지향, 테스트
>
> 테스트하기 쉬운 코드가 좋은 코드이다.

<br> 

### 내용
- 애플리케이션은 계속 변하고 복잡해지는데, 그 변화에 대응하는 전략으로 
  1. 객체지향적인 설계와 그것을 담아낼 수 있는 `IoC/DI` 기술
  2. 만들어진 코드를 확신하고 변화에 대처할 자신감을 주는 `테스트` 기술
- 테스트의 관심이 다르면, 테스트할 대상을 분리하고 집중해서 접근
  - 여기서 단위는, 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위
- 테스트는 실행과, 검증이 자동화 되어야 의미가 있음 (`xUnit` 프레임워크 사용 권장)
- 테스트는 외부 상태에 따라 영향을 받으면 안되고, 코드에 변경사항이 없다면 항상 동일한 결과를 내야 한다.
- 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 내야 한다.
- 테스트는 성공케이스보다 `예외케이스`(네거티브 테스트)를 우선해서 생각해 만든다.
- 테스트코드도 리팩토링이 필요하다.
- Junit 의 테스트 수행 방식 (**각 테스트 메소드 실행할 때마다 텟트 클래스의 오브젝트를 새로 만든다**)
  1. 테스트클래스에서 @Test 붙은 public void 중 파라미터 없는 메서드를 모두 찾는다.
  2. **테스트클래스 오브젝트 새로 생성**
  3. `@Before` 실행
  4. `@Test` 실행 및 결과 저장
  5. `@After` 실행
  6. 2~ 5 반복
  7. 결과 반환
- 픽스처(fixture): 테스트 수행하는 데 필요한 정보나 오브젝트
- 애플리케이션 컨텍스트는 한번만 만들고 여러 테스트가 공유해서 사용해도 된다.
  - `@RunWith`, `@ContextConfiguration`
- `@Autowired` 는 변수에 **할당** 가능한 타입을 가진 빈을 자동으로 찾는다.
- 인터페이스를 두고 DI 를 적용해야 하는 이유
  1. 소웨 개발에서 절대 바뀌지 않는 것은 없음
  2. 클래스 구현 방식은 안바뀌더라도, 인터페이스와 DI 를 적용해두면 다른 차원의 서비스 기능을 도입할 수 있음 (AOP 등)
  3. 테스트!
- `@DirtiesContext`: 테스트 메서드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는 것을 테스트컨텍스트 프레임웍에 알려준다.
  - 테스트컨텍스트는 위 어노테이션이 붙은 테스트클래스는 애플리케이션 컨텍스트 공유를 허용하지 않음
  - 메서드 레벨에서도 @DirtiesContext 적용 가능함
- 테스트를 위한 전용 설정파일을 만들어 두는 것이 편리하다.
  - 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
- 스프링컨테이너 없이 테스트가 가능하다면, 직접 오브젝트를 만들어 DI를 하고 테스트하는 것이 빠르고 좋다.
- 침투적/비침투적 기술
  - 침투적: 기술을 적용했을 때, 코드에 기술 관련 API 가 들어가거나 특정 인터페이스나 클래스를 사용하도록 강제하는 기술 (애플리케이션 코드가 해당 기술에 종속됨)
  - 비침투적: 애플리케이션 로직 코드에 영향을 주지않고 적용 가능 (기술에 종속적이지 않은 순수한 코드를 유지할 수 있게 해줌)
- 학습테스트를 잘 활용하면 매우 좋다. (기술의 사용방법을 익히고 이해를 도움)
- 버그테스트: 코드에 오류가 있을 때, 그 오류를 가장 잘 드러내줄 수 있는 테스트 (해당 버그를 원인으로 일단 실패하게 -> 성공하면 해결)

---
## 3장. 템플릿

### 생각 해볼 내용
- 템플릿이란?
- OCP (개방폐쇄원칙)
- 템플릿메소드패턴
- 전략패턴
- Micro DI
- 중첩클래스의 종류
- 내부클래스의 종류
- 템플릿/콜백
- 제네릭스 (Generics, Type parameter)
- 네거티브 테스트

> 템플릿과 콜백 을 이해하고 프레임워크 없이도 사용 가능해야지! 

<br> 

### 내용
- 개방폐쇄원칙(OCP): 변화의 특성이 다른 부분을 구분해주고, 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만드는 것
- `템플릿`은 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴이 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법
- 일반적으로 서버는 제한된 개수의 DB 커넥션을 만들어 재사용 가능한 풀로 관리하는데, 그래서 리소스를 사용하고 반환을 close() 등으로 꼭 반환 해주어야 한다.
  - 예외상황에도 리소스 반환이 되도록 try/catch/finally 를 사용한다.
- 같은 로컬스택에서 사용된 리소스는 사용의 역순으로 반환해주는게 원칙이다.
- 분리와 재사용을 위해서,
  - 변하지 않고 고정된 부분과 로직에 따라 변하는 부분을 구분한다.
- 보통은 분리한 부분이 재사용 가능하지만, 반대로 분리시키고 남은 메소드가 재사용 되어야 하는 경우가 있음
  - `템플릿메서드패턴` 사용 가능: 상속을 통해서 기능을 확장한다.
    - 로직마다 상속을 통해 새로운 클래스를 만들어야 하는 제한이 있다.
    - 클래스 레벨에서 컴파일 시점에 관계가 결정되어 있는 단점이 있다.
  - `전략패턴` 사용 가능: 정해진 `컨텍스트` 내에 변하는 `전략`을 주입하여 런타임에 구현한다.
    - 이 때, `전략`은 `컨텍스트` 앞단의 `클라이언트`가 결정하는 것이 일반적이다.
- 마이크로 DI: DI의 가장 중요한 개념은 제3자의 도움을 통해 두 오브젝트 사이의 유연한 관계 설정을 하는 것이다.
  - 일반적으로 DI 는 의존관계의 `두 오브젝트`와 이 관계를 다이나믹하게 설정해주는 `DI 컨테이너`, 이를 사용하는 `클라이언트`라는 4개 오브젝트가 있다.
  - 하지만 DI 는, 작은 단위의 코드와 메소드 사이에서도 일어난다. (= 마이크로 DI, 수동 DI)
- 전략패턴 사용시 생길 수 있는 문제 2가지로
  1. 전략 구현 클래스가 계속 생겨날 수 있는 것
  2. 전략에 전달할 부가정보가 있는 경우, 오브젝트 전달 생성자와 저장해둘 인스턴스 변수를 만들어야 한다.
  - 1,2 번 문제는 `로컬클래스`를 만들어서 해결 가능하다. (로컬클래스는 내부클래스라서 선언된 곳의 정보에 접근 가능. 단, final)
  - 이거 좀 중요한 듯, 파라미터 전달없이 접근 가능한 것.
- `중첩클래스`의 종류 2가지 (nested class)
  - `스태틱클래스` (static class): 독립적인 오브젝트로 만들어질 수 있음
  - `내부클래스` (inner class): 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있음
    - 범위에 따라 다시 3가지로 분류
    1. `멤버내부클래스` (member inner class): 멤버 필드처럼 오브젝트 레벨에 정의됨
    2. `로컬클래스` (local class): 메소드 레벨에 정의됨
    3. `익명내부클래스` (anonymous inner class): 이름을 갖지 않고, 선언 위치에 따라 범위 다름
       - 클래스 선언과 오브젝트 생성이 결합된 형태, 클래스를 재사용하지 않고 구현한 인터페이스 타입으로만 사용할 경우 사용
       - 구현하는 인터페이스를 생성자처럼 이용해서 오브젝트를 만든다.
- 스프링의 `DI` 는 객체의 `생성`과 `관계설정`에 대한 `제어권한`을 오브젝트에서 제거하고 외부로 위임했다는 `IoC` 개념을 포괄한다.
- 클래스가 구분되어 있어도 논리적으로 긴밀한 관계로 강한 응집도를 갖고있다면, 인터페이스를 사용하지 않을 수 있다.
  - 내부적으로 수동 DI 를 쓰거나 할 수 있다.
  - 정답은 없으니 상황에 따라 적절하게..
- 템플릿/콜백 패턴: `템플릿`은 전략패턴의 `컨텍스트`, `콜백`은 `익명내부클래스`로 만들어지는 전략 오브젝트이다.
  - 템플릿: 미리 만들어둔 고정된 틀 
  - 콜백: 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트, 파라미터로 전달되지만 값 참조가 아니라 로직을 담은 메소드로 실행시키기 위해 사용 (= functional object)
  - 작업흐름
    - `클라이언트`에서 `콜백` 생성해서 -> `콜백` 참조 전달 -> `템플릿`으로
    - `템플릿`에서 작업 시작 후 -> `콜백` 호출
    - `클라이언트`의 final 변수 등을 이용해서 `콜백` 실행 -> 결과를 전달 -> `템플릿`으로
    - `템플릿`의 나머지 작업 완료 후 -> 결과 전달 -> `클라이언트`로
  - 클라이언트와 콜백이 강하게 결합된다.
  - 전략패턴과 DI 장점을 익명내부클래스 사용전략과 결합한 활용법
  - 변하는 코드의 경계를 찾고, 그 경계를 사이에 두고 주고받는 일정한 정보가 있는지 확인하면 된다.
    - 코드 특성이 바뀌는 경계를 살피고, 인터페이스를 사용해 분리하는 객체지향 원칙에 충실
- 고정된 흐름으로 반복되는 코드가 있다면,
  - 중복되는 코드를 분리 (일단 가볍게 메소드로 분리 시도)
  - 일부는 인터페이스를 사이에 두고 분리해서 전략패턴 적용
  - DI 로 의존관계 관리
  - 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어질 수 있다면 템플릿/콜백 패턴 적용 고려한다.
- 네거티브 테스트: 예외상황 테스트
  - 미리 예외상황에 대한 일관성 있는 기준을 정해두고 테스트로 검증이 필요

---
## 4장. 서비스추상화

### 생각 해볼 내용
- ㅇ

> ㅇ

<br> 

### 내용
- ㅇ


---
## 5장. AOP

### 생각 해볼 내용
- ㅇ

> ㅇ

<br> 

### 내용
- ㅇ

