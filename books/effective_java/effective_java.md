# Effective Java 2/E

1. [서론](1장.-서론)
2. [객체의 생성과 삭제](#2장.-객체의-생성과-삭제)
3. [모든 객체의 공통 메서드](#3장.-모든-객체의-공통-메서드)
   - [규칙9. equals를 재정의할 때는 반드시 hashCode도 재정의하라](#규칙9.-equals를-재정의할-때는-반드시-hashCode도-재정의하라)
4. [클래스와 인터페이스](#4장.-클래스와-인터페이스)
5. [제네릭](#5장.-제네릭)
6. [열거형(enum)과 어노테이션](#6장.-열거형(enum)과-어노테이션)
7. [메서드](#7장.-메서드)
8. [일반적인 프로그래밍 원칙들](#8장.-일반적인-프로그래밍-원칙들)
9. [예외](#9장.-예외)
10. [병행성](#10장.-병행성)
11. [직렬화](#11장.-직렬화)

---

## 1장. 서론


---
## 2장. 객체의 생성과 삭제


---
## 3장. 모든 객체의 공통 메서드
#### 규칙9. equals를 재정의할 때는 반드시 hashCode도 재정의하라
- 같은 객체는 같은 해시코드 값을 가져야 한다.
- equals(Object) 메서드가 같다고 판정한 두 객체의 hashCode 값은 같아야 한다.
- equals(Object) 메서드가 다르다고 판정한 두 객체의 hashCode 값은 꼭 다를 필요는 없다.
  - 그러나 서로 다른 hashCode 값이 나오면 해시테이블 성능이 향상될 수 있다.
  - 같은 값의 다른 객체의 경우, 다른 해시값을 가지면 성능이 향상 되는 경우.
- 해시 함수는 다른 객체에는 다른 해시 코드를 반환하도록 해야 한다.
- hashCode 구현이 끝나면, 동치 관계의 객체 해시코드 값이 똑같이 계산되는지 확인한다.
  - 객체의 동치 관계: (객체 == 객체)
- equals 계산에 쓰이지 않는 필드는 **반드시** 제외해서 해시 함수를 만든다.
- 해시코드 계산 비용이 높은 변경 불가능 클래스는 객체 안에 캐시해 둘 수 있다.
  - 최초 호출까지 해시코드 초기화를 늦출 수도 있다. (lazy initialization)
```java
// lazy initialization
private volatile int hashCode;

@Override public int hashCode() {
    int result = hashCode;
    if (result == 0) {
        result = 17;
        result = 31 * result + field1;
        result = 31 * result + field2;
        hashCode = result;
    }
    return result;
}
```
- **주의할 점**: 객체의 중요 부분을 해시 코드 계산 과정에 생략하면 안된다.


---
## 4장. 클래스와 인터페이스


---
## 5장. 제네릭


---
## 6장. 열거형(enum)과 어노테이션


---
## 7장. 메서드


---
## 8장. 일반적인 프로그래밍 원칙들


---
## 9장. 예외


---
## 10장. 병행성


---
## 11장. 직렬화


---

### Reference
- Effective Java 2/E
  No newline at end of file
